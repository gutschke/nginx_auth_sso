local SESSION_TIMEOUT = 60*60
local LOGIN_TIMEOUT   = 15*60

-- Retrieve global "secret" to be used for signing
local key = ngx.shared.sso:get("secret")
ngx.log(ngx.ERR, "GLOBAL SECRET: " .. key)
if not key or key == "" then
  ngx.log(ngx.ERR, "Caller did not set $sso_secret")
  return ngx.exit(ngx.ERROR)
end

-- The caller also provides the realm that should be protected by the
-- SSO authentication.
local realm = ngx.var.sso_realm;
if not realm or realm == "" then
  ngx.log(ngx.ERR, "Caller did not set $sso_realm")
  return ngx.exit(ngx.ERROR)
end

-- Convert time to four raw bytes
function TimeToRaw(tm)
  tm = math.abs(tm)
  local raw = ""
  for i = 1, 4 do
    raw = raw .. string.char(tm % 256)
    tm = tm / 256
  end
  return raw
end

-- Convert four raw bytes to time
function RawToTime(raw)
  local tm0, tm1, tm2, tm3 = raw:byte(1, 4)
  return ((tm3*256 + tm2)*256 + tm1)*256 + tm0
end

-- Read matching line from "auth-sso" file
function ReadSSO(user)
  local handle, msg, err = io.open("/etc/sso-auth", "r")
  if not handle then return end

  for line in handle:lines() do
    local u,h,r = line:
                  match("([^#]*).*"):
                  match("^%s*([^%s]*)%s+([^%s]*)%s+([^%s]*).*$")
    if u and h and r and u ~= "" and h ~= "" and r ~= "" then
      if u == user then
        handle:close()
        return u, h, r
      end
    end
  end
  handle:close()
  return
end

-- Retrieve cookie value as table
function GetCookieValue()
  local auth = { }
  local cookie = ngx.var.cookie_SSOAuth
  if cookie then
    local hmac, realms = ngx.decode_base64(cookie):
                         match("^(" .. string.rep(".", 20) .. ")(.*)$")
    if hmac and hmac ~= "" and realms and realms ~= "" and
       ngx.hmac_sha1(key, realms) == hmac then
      for tm_raw, r in realms:gmatch("(....)([^%z]+)%z?") do
        local diff = ngx.time() - RawToTime(tm_raw)
        if diff >= 0 and diff < SESSION_TIMEOUT then
          auth[r] = tm_raw
        end
      end
    end
  end
  return auth
end

-- Extend the time that the user is logged into this realm
function ExtendCookieDuration(realm, force)
  local auth = GetCookieValue()
  local authorized = (auth[realm] ~= nil)

  if authorized or force then
    auth[realm] = TimeToRaw(ngx.time())
    local realms = ""
    for r, tm_raw in pairs(auth) do
      realms = realms .. "\000" .. tm_raw .. r
    end
    realms = realms:sub(2, -1)
    if realms ~= "" then
      realms = ngx.encode_base64(ngx.hmac_sha1(key, realms) .. realms)
      local cookie = "SSOAuth=" .. realms .. "; path=/" .. "; HttpOnly"
      if ngx.var.scheme == "https" then
        cookie = cookie .. "; secure"
      end
      if not force then
        ngx.ctx.sso_set_cookie = cookie
      else
        ngx.header["Set-Cookie"] = cookie
      end
    end
  end
  return authorized
end

-- If the user has a valid cookie, allow the request
if ExtendCookieDuration(realm, false) then
  return ngx.exit(ngx.OK)
end

-- The user submitted a user id and password. Verify the provided information
-- and then decide whether to allow the request.
if ngx.req.get_method() == "POST" then
  repeat
    -- Read POST arguments. This includes user id, hashed password, and other
    -- data.
    ngx.req.read_body()
    local args, err = ngx.req.get_post_args()
    if not args then break end

    -- If this was a request for a user's "salt", handle that here.
    local user = args["sso_salt_request"]
    if user then
      local u, h, r = ReadSSO(user)
      if u == user then
        -- Return the "salt" value in a custom header.
        ngx.header["X-Salt"] = h:match("([^:]*)")
      else
        -- If the user doesn't exist, make-up a fake, but plausible "salt" value.
        ngx.header["X-Salt"] = ngx.encode_base64(ngx.hmac_sha1(key, user)):sub(1, 8)
      end
      return ngx.exit(200)
    end

    -- Make sure we got all the arguments that we need to make a decision
    user = args["sso_auth_user"]
    local challenge = args["sso_auth_challenge"]
    local password_hash = args["sso_auth_password_hash"]
    if not user or user == "" or
       not challenge or challenge == "" or
       not password_hash or password_hash == "" then
      break
    end

    -- Check signature on signed "challenge"
    local tm_raw, tm_hmac = ngx.decode_base64(challenge):match("(....)(.*)")
    if ngx.hmac_sha1(key, tm_raw) ~= tm_hmac then break end

    -- Compute time when challenge was issued and reconfirm the password if
    -- the password dialog has expired
    local diff = ngx.time() - RawToTime(tm_raw)
    if diff < 0 or diff >= LOGIN_TIMEOUT then
      break
    end

    -- Read "sso-auth" file
    local u, h, r = ReadSSO(user)
    if u == user then
      -- Check if the password matches.
      local salt, hash = h:match("([^:]*):(.*)")
      local dat1 = ngx.hmac_sha1(ngx.decode_base64(challenge), ngx.decode_base64(hash))
      local dat2 = ngx.decode_base64(password_hash)
      local data = ''
      for i = 1, #dat1 do
        data = data .. string.char((256 + dat2:byte(i) - dat1:byte(i)) % 256)
      end
      if ngx.encode_base64(ngx.sha1_bin(data)) == hash then
        -- Check if the user has access to this particular "realm"
        for s in r:gmatch("[^,]+") do
          if realm == s then
            -- The user provided a correct user id and password for this realm;
            -- allow the request.
            ExtendCookieDuration(realm, true)
            return ngx.exit(ngx.HTTP_OK)
          end
        end
      end
    end
  until true
end

-- The user is (still) unauthenticated. Inject a login page and ask for
-- credentials.
ngx.req.set_method(ngx.HTTP_GET)
ngx.header["Content-Type"] = "text/html"
return ngx.exec("/auth")
